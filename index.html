<!DOCTYPE html>
<html>

<head>
  <!-- Include prism.css to style the code -->
  <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/themes/prism.min.css" rel="stylesheet" />
</head>

<body>
  <p>
    <!-- Use pre and code elements to wrap your code -->
    <!-- The class "language-xyz" specifies the language of the code -->
  <pre><code class="language-javascript">
    //BFS
    #include <stdio.h>

#define MAX 10

int queue[MAX], front = 0, rear = 0;

void enqueue(int value)
{
  queue[rear++] = value;
}

int dequeue()
{
  return queue[front++];
}

void BFS(int graph[MAX][MAX], int visited[MAX], int start, int n)
{
  enqueue(start);
  visited[start] = 1;

  while (front < rear)
  {
    int current = dequeue();
    printf("%d ", current);

    for (int i = 0; i < n; i++)
    {
      if (graph[current][i] == 1 && visited[i] == 0)
      {
        enqueue(i);
        visited[i] = 1;
      }
    }
  }
}

int main()
{
  int n;
  printf("Enter number of nodes: ");
  scanf("%d", &n);

  int graph[MAX][MAX];
  int visited[MAX] = {0};

  printf("Enter adjacency matrix:\n");
  for (int i = 0; i < n; i++)
  {
    for (int j = 0; j < n; j++)
    {
      scanf("%d", &graph[i][j]);
    }
  }

  int start;
  printf("Enter starting node: ");
  scanf("%d", &start);

  printf("BFS traversal starting from node %d:\n", start);
  BFS(graph, visited, start, n);

  return 0;
}

        </code></pre>
  </p>


  <p>
    <!-- Use pre and code elements to wrap your code -->
    <!-- The class "language-xyz" specifies the language of the code -->
  <pre><code class="language-javascript">
//BINARY SEARCH TREE
#include <stdio.h>
int binarySearch(int nums[], int lb, int ub, int target)
{

  int mid = (lb + ub) / 2;
  if (nums[mid] == target)
  {
    return mid;
  }
  else
  {
    if (nums[mid] < target)
    {
      binarySearch(nums, mid + 1, ub, target);
    }
    else
    {
      binarySearch(nums, lb, mid - 1, target);
    }
  }
}

int main()
{
  int nums[] = {5, 7, 8, 9, 10, 11, 12, 15};

  int foundNum = binarySearch(nums, 0, 7, 11);
  printf("The required no. is at position: %d", foundNum);
}

      </code></pre>
  </p>


  <p>
    <!-- Use pre and code elements to wrap your code -->
    <!-- The class "language-xyz" specifies the language of the code -->
  <pre><code class="language-javascript">
//DFS
#include <stdio.h>

#define MAX 10

int stack[MAX], top = -1;

void push(int value)
{
  stack[++top] = value;
}

int pop()
{
  return stack[top--];
}

void DFS(int graph[MAX][MAX], int visited[MAX], int start, int n)
{
  push(start);

  while (top != -1)
  {
    int current = pop();

    // If the node is not visited, mark it as visited and print it
    if (!visited[current])
    {
      printf("%d ", current);
      visited[current] = 1;
    }

    // Push all unvisited neighbors onto the stack
    for (int i = n - 1; i >= 0; i--)
    { // Reverse order for proper traversal
      if (graph[current][i] == 1 && visited[i] == 0)
      {
        push(i);
      }
    }
  }
}

int main()
{
  int n;
  printf("Enter number of nodes: ");
  scanf("%d", &n);

  int graph[MAX][MAX];
  int visited[MAX] = {0};

  printf("Enter adjacency matrix:\n");
  for (int i = 0; i < n; i++)
  {
    for (int j = 0; j < n; j++)
    {
      scanf("%d", &graph[i][j]);
    }
  }

  int start;
  printf("Enter starting node: ");
  scanf("%d", &start);

  printf("DFS traversal starting from node %d:\n", start);
  DFS(graph, visited, start, n);

  return 0;
}

      </code></pre>
  </p>
  <p>
    <!-- Use pre and code elements to wrap your code -->
    <!-- The class "language-xyz" specifies the language of the code -->
  <pre><code class="language-javascript">
    //MIN MAX recursion
   
       
       
      #include <stdio.h>

struct Pair
{
  int min;
  int max;
};

struct Pair findMinMax(int arr[], int low, int high)
{
  struct Pair minmax, left, right;
  int mid;

  if (low == high)
  {
    minmax.min = arr[low];
    minmax.max = arr[low];
    return minmax;
  }

  if (high == low + 1)
  {
    if (arr[low] < arr[high])
    {
      minmax.min = arr[low];
      minmax.max = arr[high];
    }
    else
    {
      minmax.min = arr[high];
      minmax.max = arr[low];
    }
    return minmax;
  }

  mid = (low + high) / 2;
  left = findMinMax(arr, low, mid);
  right = findMinMax(arr, mid + 1, high);

  if (left.min < right.min)
  {
    minmax.min = left.min;
  }
  else
  {
    minmax.min = right.min;
  }

  if (left.max > right.max)
  {
    minmax.max = left.max;
  }
  else
  {
    minmax.max = right.max;
  }

  return minmax;
}

int main()
{
  int arr[] = {1000, 11, 445, 1, 330, 3000};
  int n = sizeof(arr) / sizeof(arr[0]);
  struct Pair minmax = findMinMax(arr, 0, n - 1);

  printf("Minimum element is %d\n", minmax.min);
  printf("Maximum element is %d\n", minmax.max);

  return 0;
}
      
      </code></pre>
  </p>
  <p>
    <!-- Use pre and code elements to wrap your code -->
    <!-- The class "language-xyz" specifies the language of the code -->
  <pre><code class="language-javascript">
//JOB SEQUENCE
#include <stdio.h>
#include <stdbool.h>

struct Job
{
  char id;
  int profit;
  int deadline;
};

void sortJobs(struct Job jobs[], int n)
{
  // bubble sort the jobs sequence
}

void jobSequencing(struct Job jobs[], int n)
{
  sortJobs(jobs, n);
  // find  max deadline here..
  int maxDeadline = 0;
  for (int i = 0; i <= n; i++)
  {
    if (jobs[i].deadline > maxDeadline)
    {
      maxDeadline = jobs[i].deadline;
    }
  }

  bool slots[3];
  bool result[4];
  int totalProfit = 0;

  for (int i = 0; i < maxDeadline; i++)
  {
    slots[i] = false;
  }

  for (int i = 0; i < n; i++)
  {
    for (int j = jobs[i].deadline - 1; j >= 0; j--)
    {
      if (!slots[j])
      {
        slots[j] = true;
        result[j] = jobs[i].id;
        totalProfit += jobs[j].profit;
        break;
      }
    }
  }
  for (int i = 0; i < maxDeadline; i++)
  {
    if (slots[i])
    {
      printf("%c", result[i]);
    }
  }
}

int main()
{
  struct Job jobs[] = {{"a", 100, 20}, {"b", 30, 100}, {"c", 50, 90}};
  int n = 3;
  jobSequencing(jobs, n);
  return 0;
}

      </code></pre>
  </p>
  <p>
    <!-- Use pre and code elements to wrap your code -->
    <!-- The class "language-xyz" specifies the language of the code -->
  <pre><code class="language-javascript">
//KNAPSACK PROBLEM
#include <stdio.h>

// Define a structure to represent an object
typedef struct
{
  int profit;
  int weight;
} Object;

// Function to sort objects by profit/weight ratio in descending order
void sortObjects(Object objects[], int n)
{
  for (int i = 0; i < n - 1; i++)
  {
    for (int j = 0; j < n - 1 - i; j++)
    {
      double ratio1 = (double)objects[j].profit / objects[j].weight;
      double ratio2 = (double)objects[j + 1].profit / objects[j + 1].weight;
      if (ratio1 < ratio2)
      {
        Object temp = objects[j];
        objects[j] = objects[j + 1];
        objects[j + 1] = temp;
      }
    }
  }
}

// Function to calculate the maximum profit
double calculateProfit(Object objects[], int n, int bagSize)
{
  double profit = 0.0;
  int i = 0;

  while (bagSize > 0 && i < n)
  {
    if (bagSize < objects[i].weight)
    {
      profit += ((double)objects[i].profit / objects[i].weight) * bagSize;
      bagSize = 0;
    }
    else
    {
      bagSize -= objects[i].weight;
      profit += objects[i].profit;
    }
    i++;
  }

  return profit;
}

// Main function
int main()
{
  int bagSize = 15;
  double profit;

  // Create objects
  Object objects[] = {
      {10, 2},
      {5, 3},
      {15, 5},
      {7, 7},
      {6, 1},
      {18, 4},
      {3, 6}};

  int n = sizeof(objects) / sizeof(objects[0]);

  // Sort objects by profit-to-weight ratio
  sortObjects(objects, n);

  // Calculate maximum profit
  profit = calculateProfit(objects, n, bagSize);

  // Print the profit
  printf("The profit is: %.2f\n", profit);

  return 0;
}

  
      </code></pre>
  </p>
  <p>
    <!-- Use pre and code elements to wrap your code -->
    <!-- The class "language-xyz" specifies the language of the code -->
  <pre><code class="language-javascript">
//MERGE SORT
#include <stdio.h>

void merge(int arr[], int left, int mid, int right)
{
  int i, j, k;
  int n1 = mid - left + 1;
  int n2 = right - mid;

  int L[n1], R[n2];

  for (i = 0; i < n1; i++)
    L[i] = arr[left + i];
  for (j = 0; j < n2; j++)
    R[j] = arr[mid + 1 + j];

  i = 0;
  j = 0;
  k = left;

  while (i < n1 && j < n2)
  {
    if (L[i] <= R[j])
    {
      arr[k] = L[i];
      i++;
    }
    else
    {
      arr[k] = R[j];
      j++;
    }
    k++;
  }

  while (i < n1)
  {
    arr[k] = L[i];
    i++;
    k++;
  }

  while (j < n2)
  {
    arr[k] = R[j];
    j++;
    k++;
  }
}

void mergeSort(int arr[], int left, int right)
{
  if (left < right)
  {
    int mid = left + (right - left) / 2;

    mergeSort(arr, left, mid);
    mergeSort(arr, mid + 1, right);

    merge(arr, left, mid, right);
  }
}

void printArray(int arr[], int size)
{
  int i;
  for (i = 0; i < size; i++)
    printf("%d ", arr[i]);
  printf("\n");
}

int main()
{
  int arr[] = {38, 27, 43, 3, 9, 82, 10};
  int arr_size = sizeof(arr) / sizeof(arr[0]);

  printf("Given array is: \n");
  printArray(arr, arr_size);

  mergeSort(arr, 0, arr_size - 1);

  printf("\nSorted array is: \n");
  printArray(arr, arr_size);
  return 0;
}

      </code></pre>
  </p>
  <p>
    <!-- Use pre and code elements to wrap your code -->
    <!-- The class "language-xyz" specifies the language of the code -->
  <pre><code class="language-javascript">
//QUICKSORT
#include <stdio.h>

// Function to partition the array into two halves
int partition(int arr[], int low, int high)
{
  int pivot = arr[high]; // Choose the last element as the pivot
  int i = low - 1;       // Index for smaller element

  for (int j = low; j < high; j++)
  {
    // If the current element is smaller than or equal to the pivot
    if (arr[j] <= pivot)
    {
      i++;
      // Swap arr[i] and arr[j]
      int temp = arr[i];
      arr[i] = arr[j];
      arr[j] = temp;
    }
  }

  // Swap arr[i + 1] and pivot (arr[high])
  int temp = arr[i + 1];
  arr[i + 1] = arr[high];
  arr[high] = temp;

  return i + 1; // Return the partition index
}

// Function to implement quicksort
void quickSort(int arr[], int low, int high)
{
  if (low < high)
  {
    // Partition the array and get the pivot index
    int pi = partition(arr, low, high);

    // Recursively sort elements before and after partition
    quickSort(arr, low, pi - 1);
    quickSort(arr, pi + 1, high);
  }
}

// Function to print an array
void printArray(int arr[], int size)
{
  for (int i = 0; i < size; i++)
  {
    printf("%d ", arr[i]);
  }
  printf("\n");
}

// Main function
int main()
{
  int arr[] = {10, 7, 8, 9, 1, 5};
  int n = sizeof(arr) / sizeof(arr[0]);

  printf("Original array: \n");
  printArray(arr, n);

  quickSort(arr, 0, n - 1);

  printf("Sorted array: \n");
  printArray(arr, n);

  return 0;
}

      </code></pre>
  </p>
  <p>
    <!-- Use pre and code elements to wrap your code -->
    <!-- The class "language-xyz" specifies the language of the code -->
  <pre><code class="language-javascript">
//RECURSIVE MINMAX
#include <stdio.h>

int findMin(int arr[], int start, int end)
{
  if (start == end)
  {
    return arr[start];
  }
  else
  {
    int mid = (start + end) / 2;
    int leftmin = findMin(arr, start, mid);
    int rightmin = findMin(arr, mid + 1, end);

    if (leftmin < rightmin)
    {
      return leftmin;
    }
    else
    {
      return rightmin;
    }
  }
}

int findMax(int arr[], int start, int end)
{
  if (start == end)
  {
    return arr[start];
  }
  else
  {

    int mid = (start + end) / 2;
    int leftMax = findMax(arr, start, mid);
    int rightMax = findMax(arr, mid + 1, end);

    if (rightMax > leftMax)
    {
      return rightMax;
    }
    else
    {
      return leftMax;
    }
  }
}

int main()
{
  int arr[] = {3, 6, 2, 1, 4, 88};
  printf("%d and %d", findMin(arr, 0, 5), findMax(arr, 0, 5));
}
      </code></pre>
  </p>
  <p>
    <!-- Use pre and code elements to wrap your code -->
    <!-- The class "language-xyz" specifies the language of the code -->
  <pre><code class="language-javascript">
//TOWER OF HANOI
    #include <stdio.h>

void towerOfHanoi(int n, char from_rod, char to_rod, char aux_rod) {
    if (n == 1) {
        printf("\\n Move disk 1 from rod %c to rod %c", from_rod, to_rod);
        return;
    }
    towerOfHanoi(n-1, from_rod, aux_rod, to_rod);
    printf("\\n Move disk %d from rod %c to rod %c", n, from_rod, to_rod);
    towerOfHanoi(n-1, aux_rod, to_rod, from_rod);
}

int main() {
    int n = 4;  // Number of disks
    towerOfHanoi(n, 'A', 'C', 'B');  // A, B and C are names of rods
    return 0;
}

      </code></pre>
  </p>
  <p>
    <!-- Use pre and code elements to wrap your code -->
    <!-- The class "language-xyz" specifies the language of the code -->
  <pre><code class="language-javascript">
//QUEUW LINKED LIST
    #include <stdio.h>
#include <stdlib.h>

// Define structure for queue node
struct Node {
    int data;
    struct Node* next;
};

// Define structure for queue
struct Queue {
    struct Node *front, *rear;
};

// Function to create a new node
struct Node* newNode(int data) {
    struct Node* temp = (struct Node*)malloc(sizeof(struct Node));
    temp->data = data;
    temp->next = NULL;
    return temp;
}

// Function to create a new queue
struct Queue* createQueue() {
    struct Queue* queue = (struct Queue*)malloc(sizeof(struct Queue));
    queue->front = queue->rear = NULL;
    return queue;
}

// Function to check if the queue is empty
int isEmpty(struct Queue* queue) {
    return (queue->front == NULL);
}

// Function to enqueue an element
void enqueue(struct Queue* queue, int data) {
    // Create a new node
    struct Node* temp = newNode(data);

    // If queue is empty, update front and rear
    if (queue->rear == NULL) {
        queue->front = queue->rear = temp;
        return;
    }

    // Add the new node at the end of queue and update rear
    queue->rear->next = temp;
    queue->rear = temp;
}

// Function to dequeue an element
void dequeue(struct Queue* queue) {
    // If queue is empty, return
    if (isEmpty(queue)) {
        printf("Queue is empty\n");
        return;
    }

    // Store previous front and move front one node ahead
    struct Node* temp = queue->front;
    queue->front = queue->front->next;

    // If front becomes NULL, update rear as NULL
    if (queue->front == NULL)
        queue->rear = NULL;

    printf("Element deleted from queue is : %d\n", temp->data);
    free(temp);
}

// Function to display all elements of queue
void display(struct Queue* queue) {
    // If queue is empty, return
    if (isEmpty(queue)) {
        printf("Queue is empty\n");
        return;
    }

    // Traverse the queue and print all elements
    struct Node* temp = queue->front;
    printf("Queue elements are:\n");
    while (temp != NULL) {
        printf("%d ", temp->data);
        temp = temp->next;
    }
    printf("\n");
}

int main() {
    // Create an empty queue
    struct Queue* queue = createQueue();

    int choice, data;
    while (1) {
        printf("1. Insert element to queue\n");
        printf("2. Delete element from queue\n");
        printf("3. Display all elements of queue\n");
        printf("4. Quit\n");
        printf("Enter your choice: ");
        scanf("%d", &choice);
        switch (choice) {
            case 1:
                printf("Input the element for insertion in queue: ");
                scanf("%d", &data);
                enqueue(queue, data);
                break;
            case 2:
                dequeue(queue);
                break;
            case 3:
                display(queue);
                break;
            case 4:
                return 0;
            default:
                printf("Wrong choice\n");
        }
    }
    return 0;
}

      </code></pre>
  </p>
  <p>
    <!-- Use pre and code elements to wrap your code -->
    <!-- The class "language-xyz" specifies the language of the code -->
  <pre><code class="language-javascript">
//STACK LINKED LIST
    #include <stdio.h>
#include <stdlib.h>

// Define structure for stack node
struct Node {
    int data;
    struct Node* next;
};

// Function to create a new node
struct Node* newNode(int data) {
    struct Node* temp = (struct Node*)malloc(sizeof(struct Node));
    temp->data = data;
    temp->next = NULL;
    return temp;
}

// Function to push an element onto the stack
void push(struct Node** top, int data) {
    struct Node* newNode = createNode(data);
    newNode->next = *top;
    *top = newNode;
}

// Function to check if the stack is empty
int isEmpty(struct Node* top) {
    return (top == NULL);
}

// Function to peep (view) the top element of the stack
void peep(struct Node* top) {
    if (isEmpty(top)) {
        printf("STACK IS EMPTY\n");
    } else {
        printf("%d\n", top->data);
    }
}

// Function to pop an element from the stack
void pop(struct Node** top) {
    if (isEmpty(*top)) {
        printf("STACK IS EMPTY\n");
    } else {
        struct Node* temp = *top;
        *top = (*top)->next;
        printf("Popped element: %d\n", temp->data);
        free(temp);
    }
}

int main() {
    struct Node* top = NULL;
    int choice, item;

    while (1) {
        printf("1. Push\n");
        printf("2. Pop\n");
        printf("3. Peep\n");
        printf("4. Exit\n");
        printf("Enter your choice: ");
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                printf("Enter the item to be pushed: ");
                scanf("%d", &item);
                push(&top, item);
                break;
            case 2:
                pop(&top);
                break;
            case 3:
                peep(top);
                break;
            case 4:
                exit(0);
            default:
                printf("Invalid choice\n");
        }
    }

    return 0;
}

      </code></pre>
  </p>
  <p>
    <!-- Use pre and code elements to wrap your code -->
    <!-- The class "language-xyz" specifies the language of the code -->
  <pre><code class="language-javascript">
function helloWorld() {
  console.log("Hello, world!");
}
      </code></pre>
  </p>




  <!-- Include prism.js to highlight the syntax -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/prism.min.js"></script>
</body>

</html>

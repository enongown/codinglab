<html>
<pre>
  BINARY SEARCH TREE
#include <stdio.h>
#include <stdlib.h>

struct node
{
  struct node *right;
  int info;
  struct node *left;
};

struct node *find(struct node *root, int item, struct node **loc, struct node **par)
{
  *loc = NULL;
  *par = NULL;

  struct node *save = NULL;
  struct node *ptr = root;

  while (ptr != NULL)
  {
    if (item == ptr->info)
    {
      *loc = ptr;
      return root;
    }
    else
    {
      save = ptr;
      if (item < ptr->info)
        ptr = ptr->left;
      else
        ptr = ptr->right;
    }
  }
  *par = save;
  return root;
}

struct node *insert_bst(struct node *root, int item)
{
  struct node *loc, *par;
  root = find(root, item, &loc, &par);

  if (loc != NULL)
  {
    printf("\n Item already exists\n");
    return root;
  }

  struct node *new_node = (struct node *)malloc(sizeof(struct node));
  if (new_node == NULL)
  {
    printf("\n Memory allocation failed\n");
    exit(1);
  }

  new_node->info = item;
  new_node->left = NULL;
  new_node->right = NULL;

  if (par == NULL)
    return new_node;

  if (item < par->info)
    par->left = new_node;
  else
    par->right = new_node;

  return root;
}

void caseA(struct node **root, struct node *loc, struct node *par)
{
  struct node *child = NULL;

  if (loc->left == NULL && loc->right == NULL)
    child = NULL;
  else if (loc->left != NULL)
    child = loc->left;
  else
    child = loc->right;

  if (par != NULL)
  {
    if (loc == par->left)
      par->left = child;
    else
      par->right = child;
  }
  else
  {
    *root = child;
  }

  free(loc);
}

void caseB(struct node **root, struct node *loc, struct node *par)
{
  struct node *save = loc;
  struct node *ptr = loc->right;

  while (ptr->left != NULL)
  {
    save = ptr;
    ptr = ptr->left;
  }

  struct node *suc = ptr;
  struct node *parsuc = save;

  caseA(root, suc, parsuc);

  if (par != NULL)
  {
    if (loc == par->left)
      par->left = suc;
    else
      par->right = suc;
  }
  else
  {
    *root = suc;
  }

  suc->left = loc->left;
  suc->right = loc->right;

  free(loc);
}

void deletion_bst(struct node **root)
{
  if (*root == NULL)
  {
    printf("\n Tree is empty\n");
    return;
  }

  int item;
  printf("\n Enter the item to delete: ");
  scanf("%d", &item);

  struct node *loc, *par;
  *root = find(*root, item, &loc, &par);

  if (loc == NULL)
  {
    printf("Item doesn't exist\n");
    return;
  }

  if (loc->left != NULL && loc->right != NULL)
    caseB(root, loc, par);
  else
    caseA(root, loc, par);
}

void inorder(struct node *root)
{
  if (root != NULL)
  {
    inorder(root->left);
    printf("%d\n", root->info);
    inorder(root->right);
  }
}

int main()
{
  struct node *root = NULL;
  int choice, item;

  do
  {
    printf("\n1--> Insert\n2--> Traverse\n3--> Delete\n4--> Exit\n");
    printf("Enter your choice: ");
    scanf("%d", &choice);

    switch (choice)
    {
    case 1:
      printf("\nEnter the item to insert: ");
      scanf("%d", &item);
      root = insert_bst(root, item);
      break;
    case 2:
      printf("\nInorder traversal of the tree:\n");
      inorder(root);
      break;
    case 3:
      deletion_bst(&root);
      break;
    case 4:
      printf("\nExiting...\n");
      break;
    default:
      printf("\nInvalid choice. Please enter a valid option.\n");
    }
  } while (choice != 4);

  return 0;
}
    
</pre>
    QUICSORT 

    #include <stdio.h>

// Function to swap two elements
void swap(int* a, int* b) {
    int temp = *a;
    *a = *b;
    *b = temp;
}

// Function to partition the array on the basis of pivot element
int partition(int arr[], int low, int high) {
    int pivot = arr[high];  // pivot
    int i = (low - 1);  // Index of smaller element

    for (int j = low; j <= high - 1; j++) {
        // If current element is smaller than or equal to pivot
        if (arr[j] <= pivot) {
            i++;  // increment index of smaller element
            swap(&arr[i], &arr[j]);
        }
    }
    swap(&arr[i + 1], &arr[high]);
    return (i + 1);
}

// Function to implement QuickSort
void quickSort(int arr[], int low, int high) {
    if (low < high) {
        // partitionIndex is partitioning index, arr[partitionIndex] is now at right place
        int partitionIndex = partition(arr, low, high);

        // Separately sort elements before partition and after partition
        quickSort(arr, low, partitionIndex - 1);
        quickSort(arr, partitionIndex + 1, high);
    }
}

// Function to print an array
void printArray(int arr[], int size) {
    for (int i = 0; i < size; i++)
        printf("%d ", arr[i]);
    printf("\n");
}

// Driver program to test above functions
int main() {
    int arr[] = {10, 7, 8, 9, 1, 5};
    int n = sizeof(arr) / sizeof(arr[0]);
    printf("Unsorted array: ");
    printArray(arr, n);
    quickSort(arr, 0, n - 1);
    printf("Sorted array: ");
    printArray(arr, n);
    return 0;
}
<pre>
LINKED LIST
  #include <stdio.h>
#include <stdlib.h>

struct node
{
  int info;
  struct node *link;
};

struct node *start = NULL;

struct node *insert_beg(struct node *start, int item)
{
  struct node *new1 = (struct node *)malloc(sizeof(struct node));
  new1->info = item;
  new1->link = start;
  start = new1;
  return start;
}

struct node *insert_end(struct node *start, int item)
{
  struct node *new1, *ptr;
  new1 = (struct node *)malloc(sizeof(struct node));
  new1->info = item;
  new1->link = NULL;
  if (start == NULL)
  {
    start = new1;
  }
  else
  {
    ptr = start;
    while (ptr->link != NULL)
    {
      ptr = ptr->link;
    }
    ptr->link = new1;
  }
  return start;
}

struct node *delete_beg(struct node *start)
{
  struct node *ptr;
  if (start == NULL)
  {
    printf("Underflow\\n");
    return start;
  }
  else
  {
    ptr = start;
    start = start->link;
    free(ptr);
  }
  return start;
}

struct node *delete_end(struct node *start)
{
  struct node *ptr, *preptr;
  if (start == NULL)
  {
    printf("Underflow\\n");
    return start;
  }
  else if (start->link == NULL)
  {
    free(start);
    start = NULL;
  }
  else
  {
    ptr = start;
    while (ptr->link != NULL)
    {
      preptr = ptr;
      ptr = ptr->link;
    }
    preptr->link = NULL;
    free(ptr);
  }
  return start;
}

void traverse(struct node *start)
{
  struct node *ptr;
  if (start == NULL)
  {
    printf("Linked list is empty\\n");
  }
  else
  {
    ptr = start;
    while (ptr != NULL)
    {
      printf("%d ", ptr->info);
      ptr = ptr->link;
    }
    printf("\\n");
  }
}

int main()
{
  int choice, item;
  while (1)
  {
    printf("1.Insert at beginning\\n");
    printf("2.Insert at end\\n");
    printf("3.Delete from beginning\\n");
    printf("4.Delete from end\\n");
    printf("5.Traverse\\n");
    printf("6.Exit\\n");
    printf("Enter your choice: ");
    scanf("%d", &choice);

    switch (choice)
    {
    case 1:
      printf("Enter the item to be inserted: ");
      scanf("%d", &item);
      start = insert_beg(start, item);
      break;
    case 2:
      printf("Enter the item to be inserted: ");
      scanf("%d", &item);
      start = insert_end(start, item);
      break;
    case 3:
      start = delete_beg(start);
      break;
    case 4:
      start = delete_end(start);
      break;
    case 5:
      traverse(start);
      break;
    case 6:
      exit(0);
    default:
      printf("Invalid choice\\n");
    }
  }
}
    
</pre>
    <pre>

    
    </pre>
<pre>

    
</pre>

<pre>

    
</pre>
    <pre>

    
    </pre>
</html>
